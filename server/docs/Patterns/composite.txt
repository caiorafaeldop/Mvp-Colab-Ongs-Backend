COMPOSITE PATTERN (Estrutural)
=============================

CONTEXTO NO PROJETO:
- Sistema de colabora√ß√£o entre ONGs com hierarquias organizacionais
- Organiza√ß√µes podem ter filiais (matriz ‚Üí filiais ‚Üí sub-filiais)
- Opera√ß√µes devem funcionar tanto em organiza√ß√µes individuais quanto em grupos
- Necessidade de calcular m√©tricas agregadas (produtos, doa√ß√µes) recursivamente

PROBLEMA:
- Como tratar organiza√ß√µes individuais e grupos de organiza√ß√µes uniformemente?
- Como executar opera√ß√µes em toda uma hierarquia organizacional?
- Como evitar c√≥digo duplicado para opera√ß√µes em √°rvores de organiza√ß√µes?

SOLU√á√ÉO - COMPOSITE PATTERN:
Comp√µe objetos em estruturas de √°rvore para representar hierarquias parte-todo.
Permite que clientes tratem objetos individuais e composi√ß√µes uniformemente.

IMPLEMENTA√á√ÉO:

1. COMPONENT (OrganizationComponent):
   - Interface base para organiza√ß√µes
   - Define opera√ß√µes comuns: getTotalProducts(), getTotalDonations(), display()
   - M√©todos abstratos para add(), remove(), getChild()

2. LEAF (OrganizationLeaf):
   - Organiza√ß√µes folha (sem filiais)
   - Implementa opera√ß√µes b√°sicas
   - N√£o pode ter filhas (add/remove lan√ßam exce√ß√£o)
   - Opera√ß√µes retornam dados apenas desta organiza√ß√£o

3. COMPOSITE (OrganizationComposite):
   - Organiza√ß√µes que podem ter filiais
   - Mant√©m lista de children (OrganizationComponent)
   - Opera√ß√µes s√£o executadas recursivamente em toda a √°rvore
   - Pode conter tanto Leafs quanto outros Composites

4. FACTORY (CompositeFactory):
   - Cria organiza√ß√µes baseado no tipo
   - Constr√≥i √°rvores completas do banco de dados
   - Gerencia inje√ß√£o de depend√™ncias (repositories)

ESTRUTURA DE ARQUIVOS:
src/domain/composite/
‚îú‚îÄ‚îÄ OrganizationComponent.js     # Interface base
‚îú‚îÄ‚îÄ OrganizationLeaf.js          # Organiza√ß√µes folha
‚îî‚îÄ‚îÄ OrganizationComposite.js     # Organiza√ß√µes com filiais

src/main/factories/
‚îî‚îÄ‚îÄ CompositeFactory.js          # Factory para criar hierarquias

CASOS DE USO:

1. ORGANIZA√á√ÉO SIMPLES (Leaf):
   - ONG independente sem filiais
   - Calcula apenas seus pr√≥prios produtos/doa√ß√µes
   - N√£o pode adicionar sub-organiza√ß√µes

2. ORGANIZA√á√ÉO MATRIZ (Composite):
   - ONG principal com filiais
   - Calcula m√©tricas agregadas de toda a rede
   - Pode adicionar/remover filiais
   - Opera√ß√µes recursivas em toda a √°rvore

3. FILIAL COM SUB-FILIAIS (Composite):
   - Filial que tamb√©m tem suas pr√≥prias filiais
   - Comporta-se como Composite
   - Contribui para m√©tricas da matriz

OPERA√á√ïES PRINCIPAIS:

1. getTotalProducts():
   - Leaf: retorna produtos apenas desta organiza√ß√£o
   - Composite: soma produtos desta + todas as filiais (recursivo)

2. getTotalDonations():
   - Leaf: retorna doa√ß√µes apenas desta organiza√ß√£o
   - Composite: soma doa√ß√µes desta + todas as filiais (recursivo)

3. display():
   - Leaf: exibe informa√ß√µes b√°sicas
   - Composite: exibe √°rvore completa com indenta√ß√£o

4. findById():
   - Busca organiza√ß√£o na √°rvore por ID (recursivo)

5. getOrganizationTree():
   - Retorna estrutura hier√°rquica como JSON

EXEMPLO DE USO:

```javascript
const factory = new CompositeFactory(productRepo, donationRepo);

// Criar √°rvore de organiza√ß√µes
const matrix = await factory.buildOrganizationTree('matrix-id');

// Opera√ß√µes uniformes (funciona para Leaf ou Composite)
const totalProducts = await matrix.getTotalProducts();
const totalDonations = await matrix.getTotalDonations();

// Exibir estrutura
console.log(matrix.display());
// üìÅ ONG Matriz [COMPOSITE] (2 filiais)
//   ‚îú‚îÄ Filial Norte [COMPOSITE] (1 filiais)
//     ‚îî‚îÄ Sub-filial A [LEAF] (branch)
//   ‚îî‚îÄ Filial Sul [LEAF] (branch)

// Buscar organiza√ß√£o espec√≠fica
const org = matrix.findById('filial-id');

// √Årvore como JSON
const tree = matrix.getOrganizationTree();
```

VANTAGENS:

1. UNIFORMIDADE:
   - Mesma interface para organiza√ß√µes individuais e grupos
   - Cliente n√£o precisa distinguir entre Leaf e Composite

2. FLEXIBILIDADE:
   - F√°cil adicionar novos tipos de organiza√ß√µes
   - Estruturas hier√°rquicas din√¢micas

3. RECURSIVIDADE:
   - Opera√ß√µes autom√°ticas em toda a √°rvore
   - C√≥digo limpo e reutiliz√°vel

4. ESCALABILIDADE:
   - Suporta hierarquias de qualquer profundidade
   - Performance otimizada com lazy loading

INTEGRA√á√ÉO COM SISTEMA:

1. REPOSITORIES:
   - MongoOrganizationRepository para persist√™ncia
   - ProductRepository e DonationRepository injetados

2. CONTROLLERS:
   - OrganizationCompositeController para endpoints
   - Opera√ß√µes CRUD em hierarquias

3. SERVICES:
   - OrganizationCompositeService para l√≥gica de neg√≥cio
   - Valida√ß√µes e regras espec√≠ficas

4. ROTAS:
   - GET /organizations/:id/tree - √°rvore completa
   - GET /organizations/:id/metrics - m√©tricas agregadas
   - POST /organizations/:id/children - adicionar filial
   - DELETE /organizations/:parentId/children/:childId - remover filial

CASOS DE TESTE:

1. Criar organiza√ß√£o Leaf
2. Criar organiza√ß√£o Composite
3. Adicionar filiais a Composite
4. Remover filiais de Composite
5. Calcular m√©tricas recursivas
6. Buscar organiza√ß√µes na √°rvore
7. Exibir estrutura hier√°rquica
8. Converter para JSON

PADR√ïES RELACIONADOS:

- FACTORY: CompositeFactory cria hierarquias
- REPOSITORY: Persist√™ncia das organiza√ß√µes
- STRATEGY: Diferentes tipos de organiza√ß√µes
- VISITOR: Opera√ß√µes espec√≠ficas na √°rvore (futuro)

CONSIDERA√á√ïES:

1. PERFORMANCE:
   - Opera√ß√µes recursivas podem ser custosas
   - Implementar cache para m√©tricas frequentes
   - Lazy loading de filiais quando necess√°rio

2. CONSIST√äNCIA:
   - Validar integridade da √°rvore
   - Evitar refer√™ncias circulares
   - Transa√ß√µes para opera√ß√µes complexas

3. SEGURAN√áA:
   - Verificar permiss√µes antes de opera√ß√µes
   - Logs detalhados para auditoria
   - Valida√ß√£o de dados de entrada

STATUS: ‚úÖ IMPLEMENTADO
- Component, Leaf, Composite criados
- Factory implementada
- Opera√ß√µes b√°sicas funcionando
- Pronto para integra√ß√£o com controllers/services
